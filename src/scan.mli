(* Scanning. *)

open Core

module HashState : sig
  type t
  val show : t -> string
end

(** Turn a fetching function into a sequence.  Sequences don't require
 * that the result be evaluated in order, so we have to put a little
 * work into making sure this works (using memoize). *)
val to_seq : (unit -> 'a option) -> 'a Sequence.t

(** Scan the tree, hashing any names that don't have hashes, and adding
 * them to the hashes. *)
val hash_update : hstate:HashState.t -> string -> Sqlite3.db ->
  (unit -> Node.t option) -> unit

val hash_count : meter:Progress.t -> (unit -> Node.t option) -> HashState.t

(** Merge the hashes from the database (elts) with the nodes from
 * rnode, writing the updated nodes to wnode. *)
val merge_hashes : (int * string) Sequence.t ->
  (unit -> Node.t option) -> (Node.t -> unit) -> unit

(** cp_hashes older latest -> dest.  Using the tree generated by
 * 'older', makes a copy of 'latest', updating the hashes in files
 * that have not had changes to their contents. *)
val cp_hashes : older:(unit -> Node.t option) ->
  latest:(unit -> Node.t option) -> (Node.t -> unit) -> unit
